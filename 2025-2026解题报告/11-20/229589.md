**摘要：调和级数，更换枚举方式以寻找更低复杂度（A找B $\not=$ B找A）**

# 题意
多组数据， $n$ 元素 $m$ 查询，每次查询 $x(x\le n)$ ，问是否存在子集的gcd为 $x$ 。 $\sum(n+m)\le10^6$

# 分析
首先，选出的数字肯定为 $x$ 的倍数；其次，我们想让选出的数字除以 $x$ 后 gcd 为 $1$ ，所以自然是选出的数字全部用上最好。因此题目可以转化为，查询集合中所有 $x$ 的倍数的 gcd 是否为 $x$。

首先想到**调和级数**。这是非常经典的解题技巧，可以在 $O(N \log(N))$ 的时间复杂度内预处理出每个数字的所有因数，常用于需要知道多个数字的因数/倍数时。

于是笔者想到了如下做法，时间复杂度为 $O(N\log(N) + N\times T(N)\log(N) + M)$ ，其中 $T(N) $为 $N$ 的因数个数。

```cpp
vector<int>fac[N+1];    //fac[x]: x的所有因数
int g[N+1]; //g[x]: x的所有倍数的gcd

void init() {
    for (int i = 1; i <= N; ++i) {  //调和级数，预处理所有数字的因数
        for (int j = i; j <= N; j += i) {   //用因数找倍数
            fac[j].push_back(i);
        }
    }
}

void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1; i <= n; ++i) g[i] = 0;

    for (int i = 1; i <= n; ++i) {
        for (auto x : fac[a[i]]) {  //用倍数找因数
            g[x] = __gcd(g[x], a[i]);
        }
    }
    
    while (m--) {
        int x; cin >> x;
        if (g[x] == x) {
            cout << "YES" << '\n';
        } else {
            cout << "NO" << '\n';
        }
    }
}
```

但是这种做法被卡了。可能是因为$10^6$内存在因数个数较多的数字。[这篇博客](https://www.cnblogs.com/ubospica/p/10392523.html)中指出，$10^6$ 内因数个数最多的数字为 $720720$ ，有 $240$ 个因数。这会导致 $N\times T(N)log(N)$ 爆掉。

查看题解得知：

由于 $x\le n$ ，可以在每组数据内使用调和级数。输入后用桶记录每个数值是否出现过。从 $1$ 到 $n$ 遍历每个 $x$ ，找所有的倍数，如果存在，则加入计算。

这样， $N\times T(N)log(N)$ 就被优化为 $N\log^2(N)$ 。

# 代码

```cpp
int n, m;
int a[N];
int g[N+1]; //g[x]: x的所有倍数的gcd
bool flag[N+1]; //flag[x]: x是否出现过

void solve() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) flag[i] = false;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        flag[a[i]] = true;
    }

    for (int i = 1; i <= n; ++i) {  //调和级数，处理所有x及其倍数
        g[i] = 0;
        for (int j = i; j <= n; j += i) {   //用因数找倍数
            if (flag[j]) g[i] = __gcd(g[i], j);
        }
    }

    while (m--) {
        int x; cin >> x;
        if (g[x] == x) {
            cout << "YES" << '\n';
        } else {
            cout << "NO" << '\n';
        }
    }
}
```

# 总结
可以发现，就是用因数找倍数和用倍数找因数的区别。

做题时大概率不会“我要把所有找法都试一试”（如果真的到了这种地步已经很折磨了），还是比较靠感觉。


~~靠感觉的题目写什么解题报告啊。~~

