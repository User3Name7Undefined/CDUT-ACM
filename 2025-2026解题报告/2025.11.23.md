---
title: 洛谷 P6298 and CF803F
---

# 洛谷 P6298

# Solution

## 问题分析

我们需要计算对于每个 $t \in [1, m]$，选出 $k$ 个齿轮使得齿数的 **gcd 恰好等于 $t$** 的方案数，记作 $f[t]$。

## 关键思路

### 1. 定义函数

- $f[d]$：选出 $k$ 个齿轮，齿数的 **gcd 恰好等于 $d$** 的方案数
- $g[d]$：选出 $k$ 个齿轮，齿数的 **gcd 是 $d$ 的倍数** 的方案数

### 2. 容斥原理

如果 gcd 是 $d$ 的倍数，那么它可能是 $d, 2d, 3d, \ldots$。根据容斥原理：

$$
f[d] = g[d] - \sum_{j=2}^{\lfloor m/d \rfloor} f[j \cdot d]
$$

### 3. 计算 $g[d]$

从齿数是 $d$ 的倍数的齿轮中选 $k$ 个，这样的选择方案数就是 $g[d]$：

$$
g[d] = \binom{cnt[d]}{k}
$$

其中 $cnt[d]$ 表示齿数是 $d$ 的倍数的齿轮个数。

### 4. 空间优化

我们只需要一个数组 $f[d]$：

- 先用 $f[d]$ 存储 $g[d]$ 的值：$f[d] = \binom{cnt[d]}{k}$
- 然后**倒序枚举**（从 $m$ 到 $1$）进行容斥

### 5. 计算 $cnt[d]$

用调和级数枚举计算 cnt[d]：对于每个 d，枚举 d 的所有倍数，统计齿数是 d 的倍数的齿轮个数

# code

```c++
#include <bits/stdc++.h>

using i64 = long long;
const int MAX_N = 1e6 + 5;
int fact[MAX_N];
int inv[MAX_N];
int cnt[MAX_N], f[MAX_N];
const int mod = 1e9 + 7;

i64 qpow(i64 a, i64 b, i64 mod) {
  i64 ans = 1;
  while (b) {
    if (b & 1) {
      ans = ans * a % mod;
    }
    a = a * a % mod;
    b >>= 1;
  }
  return ans;
}

void init() {
  fact[0] = 1;
  inv[0] = 1;
  for (int i = 1; i < MAX_N; i++) {
    fact[i] = 1LL * fact[i - 1] * i % mod;
  }
  inv[MAX_N - 1] = qpow(fact[MAX_N - 1], mod - 2, mod);
  for (int i = MAX_N - 2; i >= 1; i--) {
    inv[i] = 1LL * inv[i + 1] * (i + 1) % mod;
  }
}

i64 C(i64 n, i64 m) {
  if (m < 0 || m > n)
    return 0;
  return 1LL * fact[n] * inv[m] % mod * inv[n - m] % mod;
}

void go() {
  init();
  int n, m, k;
  std::cin >> n >> m >> k;

  for (int i = 1; i <= n; i++) {
    int x;
    std::cin >> x;
    cnt[x]++;
  }

  // 计算 cnt[t] = 齿数是 t 的倍数的齿轮个数
  for (int i = 1; i <= m; i++) {
    for (int j = 2 * i; j <= m; j += i) {
      cnt[i] += cnt[j];
    }
  }

  // 计算 g[t] = C(cnt[t], k) （损耗因子是 t 的倍数的方案数）
  for (int i = 1; i <= m; i++) {
    f[i] = C(cnt[i], k);
  }

  // 容斥：f[t] = g[t] - sum_{j>=2} f[t*j]
  for (int i = m; i >= 1; i--) {
    for (int j = 2 * i; j <= m; j += i) {
      f[i] = (f[i] - f[j] + mod) % mod;
    }
  }

  for (int i = 1; i <= m; i++) {
    std::cout << f[i] << ' ';
  }
  std::cout << '\n';
}

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  go();
  return 0;
}
```

# CF 803F

# Solution

如果学会了洛谷那道题目这道题目就是在上面的基础上改变一下 g[d]的求法，d==1 的特殊情况

# code

```c++
#include <bits/stdc++.h>

using i64 = long long;
const int MAX_N = 1e5 + 5;
i64 pow2[MAX_N];
i64 cnt[MAX_N], f[MAX_N];
const int mod = 1e9 + 7;
void go() {
  int n;
  std::cin >> n;
  pow2[0] = 1;
  for (int i = 1; i <= n; i++) {
    pow2[i] = pow2[i - 1] * 2 % mod;
  }
  for (int i = 0; i < n; i++) {
    int x;
    std::cin >> x;
    cnt[x]++;
  }
  for (int i = 1; i < MAX_N; i++) {
    for (int j = i * 2; j < MAX_N; j += i) {
      cnt[i] += cnt[j];
    }
  }
  for (int i = 1; i < MAX_N; i++) {
    f[i] = (pow2[cnt[i]] - 1 + mod) % mod;
  }
  for (int d = MAX_N - 1; d >= 1; d--) {
    for (int j = d * 2; j < MAX_N; j += d) {
      f[d] = (f[d] - f[j] + mod) % mod;
    }
  }
  std::cout << f[1] << '\n';
}

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  go();
  return 0;
}
```

