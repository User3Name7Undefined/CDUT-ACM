# NOI2015 程序的自动分析

[题目链接](https://www.luogu.com.cn/problem/P1955)

显然并查集就可以做, 但这道题不同的是 $x$ 可能很大. 如果我们盲目用并查集, 可能会 MLE. 故我们先离散化, 强制把 $x$ 变小, 然后再利用并查集处理.

离散化

```cpp
for(int i=1;i<=n;P(i)){
	std::cin>>a[i].x>>a[i].y>>a[i].op;
	num.push_back(a[i].x);
	num.push_back(a[i].y);
}
std::sort(num.begin(),num.end());
auto p=std::unique(num.begin(),num.end());
num.erase(p,num.end());
for(int i=1;i<=n;P(i))a[i].x=std::lower_bound(num.begin(),num.end(),a[i].x)-num.begin(),a[i].y=std::lower_bound(num.begin(),num.end(),a[i].y)-num.begin();
```

并查集

```cpp
for(unsigned int i=1;i<=num.size();P(i))f[i]=i;
std::sort(a+1,a+1+n);
for(int i=1,x,y;i<=n;P(i)){
	x=find(a[i].x),y=find(a[i].y);
	if(a[i].op)f[x]=y;
	else if(x==y)return std::cout<<"NO\n",void(0);
}
```

总代码

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
#define P(A) A=-~A
#define NUMBER1 1000000
typedef long long LL;
int n,f[NUMBER1+5];
struct DATA{
	int x,y,op;
	bool operator<(const DATA &A)const{return op>A.op;}
}a[NUMBER1+5];
inline int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
inline void solve(){
	memset(a,0,sizeof(a));
	memset(f,0,sizeof(f));
	std::cin>>n;
	std::vector<int>num;
	for(int i=1;i<=n;P(i)){
		std::cin>>a[i].x>>a[i].y>>a[i].op;
		num.push_back(a[i].x);
		num.push_back(a[i].y);
	}
	std::sort(num.begin(),num.end());
	auto p=std::unique(num.begin(),num.end());
	num.erase(p,num.end());
	for(unsigned int i=1;i<=num.size();P(i))f[i]=i;
	for(int i=1;i<=n;P(i))a[i].x=std::lower_bound(num.begin(),num.end(),a[i].x)-num.begin(),a[i].y=std::lower_bound(num.begin(),num.end(),a[i].y)-num.begin();
	std::sort(a+1,a+1+n);
	for(int i=1,x,y;i<=n;P(i)){
		x=find(a[i].x),y=find(a[i].y);
		if(a[i].op)f[x]=y;
		else if(x==y)return std::cout<<"NO\n",void(0);
	}
	std::cout<<"YES\n";
}
signed main(){
	std::cin.tie(nullptr)->std::ios::sync_with_stdio(false);
	std::cout.tie(nullptr);
	int T;
	std::cin>>T;
	while(T--)solve();
	return 0;
}
```
