# 桶排序题解

[题目](https://www.luogu.com.cn/problem/T692041)

## 解法

所有数大小不超过 $1000$, 但 $N$ 特别大, 故考虑桶排序. 显然每个数字出现一次就在对应的桶数量加 $1$，即 `c[a]++` .  

## 注意

本题卡 `sort` , 故本题时限极低, 建议用 `scanf` 和 `printf` 输入输出.

## 最快的代码

```cpp
#include<cstdlib>
#include<cstring>
#include<cstdio>
#include<cctype>
typedef unsigned long long ULL;
namespace FastIo{
    typedef __uint128_t L;
    static char buf[100000],*p1=buf,*p2=buf,fw[100000],*pw=fw;
    #define gc p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++
    inline void pc(const char &ch){
    	if(pw-fw==100000)fwrite(fw,1,100000,stdout),pw=fw;
    	*pw++=ch;
	}
    #define fsh fwrite(fw,1,pw-fw,stdout),pw=fw
	struct FastMod{
        FastMod(ULL b):b(b),m(ULL((L(1)<<64)/b)){}
        ULL reduce(ULL a){
            ULL q=(ULL)((L(m)*a)>>64);
            ULL r=a-q*b;
            return r>=b?r-b:r;
        }
        ULL b,m;
    }HPOP(10);
    struct QIO{
    	char ch;
    	int st[30];
    	inline void read(int &x){
    		x=0,ch=gc;
    		while(!isdigit(ch))ch=gc;
    		while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=gc;}
		}
		inline void write(int a){
			do{st[++st[0]]=HPOP.reduce(a);a/=10;}while(a);
			while(st[0])pc(st[st[0]--]^48);
			pc('\n');
		}
	}qrw;
}
using namespace FastIo;
#define ra(n) for(register int i(1);i<=n;i=-~i)
#define P(A) A=-~A
int a[1005];
signed main(){
	int n,s;
	qrw.read(n);
	ra(n){
		qrw.read(s);
		P(a[s]);
	}
	ra(1000)
		while(a[i]--)
			qrw.write(i);
	fsh;
    exit(0);
    return 0;
}
```
