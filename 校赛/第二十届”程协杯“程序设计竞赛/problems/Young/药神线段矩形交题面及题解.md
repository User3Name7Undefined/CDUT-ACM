# 我不是药神 

## 题目大意

Alice 和 Bob 开了一家药店。这天他们进货了 $n$ 瓶药，每瓶药中有 $n$ 粒药丸。Alice 在检查这批药的时候，发现这 $n$ 瓶药中有且仅有一瓶是假药，同时她发现，如果一瓶药是真药，则里面的每粒药丸都重 500mg；如果一瓶药是假药，则里面的每粒药丸都重 510mg。Alice 告诉 Bob 有一瓶是假药，也告诉了 Bob 真药和假药的区别，她想考考 Bob，在她给定的称重方式下，至少要称重多少次才能找到这瓶假药。但是 Bob 一时想不出来，于是找了你来帮忙。

Alice 规定的称重方式如下：

- 先选择 $k$ （$k \leq n$）瓶药；
- 在选择的 $k$ 瓶药中，从第 $i$（$1 \leq i \leq k$） 瓶药中取出 $a_i$（$a_i \leq n$）粒药丸进行称重；
- 然后 Alice 会告诉你这 $\sum_{i = 1}^{k}a_i$ 粒药丸的总重量；
- $k$ 和 $a_i$ 都是你可以任选的。

可以按以上流程称重若干次。

## 输入描述

第一行一个整数 $T$，表示有 $T$ 个测试样例。

随后的 $T$ 行，每行一个整数 $n$，表示题目中描述的 $n$ 。

- $1 \leq T \leq 1e5$。
- $1 \leq n \leq 1e9$。

## 输出描述

对于每个测试样例，输出一个整数表示答案。

### 示例

**Input**
```
2
1
2
```

**Output**

```
0
1
```

## 题解

首先 $n = 1$，时，不需要称重就可以判断唯一的一瓶药是假药。

当 $n \not = 1$ 时，我们仅需要称重一次就可以找出假药。具体的，我们先对 $n$ 瓶药从 $1$ 到 $n$ 编号，然后对于第 $i$ 瓶药我们取 $i$ 粒药丸，然后称重得到重量 $M$，假设第 $j$ 瓶药是假药，则:

$$M = 500{n(n + 1) \over 2} - 500j + 510j$$

即：

$$j = {M - 500{n(n + 1) \over 2} \over 10}$$

### std

```cpp
#include <iostream>

int main () {
    int t = 1;
    std::cin >> t;
    while (t--) {
        int n = 0;
        std::cin >> n;
        std::cout << bool(n - 1) << '\n';
    }
    return 0;
}
```

### Fun Fact

为了给这道题增加难度，出题人特意选择了带有误导性的数据作为样例，相信有不少人输出过 $n - 1$。

# 线段与矩形交

## 题目大意

在笛卡尔坐标系（平面直角坐标系）中给出一条线段的左端点$(x_1, y_1)$ 和右端点 $(x_2, y_2)$；一个四边平行于轴的矩形左下角的点 $(x_l, y_l)$ 和右上角的点 $(x_r, y_r)$ 。判断线段和矩形有没有交集。

形式化的，给定集合 $A = {(x, y) | y = {y_1 - y_2 \over x_1 - x_2}(x - x_2) + y_2 \And x_1 \leq x \leq x_2}$ 和集合 $B = {(x, y) | x_l \leq x \leq x_r \And y_l \leq y \leq y_r}$，判断这两个集合有没有交集


## 输入描述

第一行一个整数 $T$，表示有 $T$ 个测试样例。

对于每个测试样例，第一行四个整数 $x_1$，$y_1$，$x_2$，$y_2$，分别表示线段靠左和靠右的一个端点；第二行四个整数 $x_l$，$y_l$，$x_r$，$y_r$，表示矩形左下角和右上角的坐标。

- $T \leq 1e5$。
- 所给出的坐标值的绝对值不超过 $1e4$。
- 保证线段不会退化成点，矩形不会退化成线段或点。

## 输出描述

对于每个测试样例，如果有交集则输出 ``YES``，否则输出``NO``。

### 示例

**Input**
```
3
0 0 5 5
0 10 10 0
0 0 5 5
6 6 6 7
0 0 5 5
1 1 2 2

```

**Output**

```
YES
NO
YES
```

## 题解

首先简单判断一种一定不相交的情况：考虑以给出的线段为对角线做一个四边都平行于轴的矩形，如果这个矩形和给定的矩形都不相交，那么线段和矩形就一定不相交。判断矩形和矩形不相交是 trivial 的。

剩下来的情况，若线段和矩形不相交，那么矩形的四个点一定在线段所在直线的同一侧，于是判断矩形的四个点是否在线段的同一侧就好了。  
我们都知道 $Ax + By + C = 0$ 是一条直线方程能够唯一确定一条直线，那么 $Ax + By + C > 0$ 就是在这条直线一侧的点，$Ax + By + C < 0$ 就是在这条直线另一侧的点。于是用以上公式判断四个点是不是在直线的同一侧就好了。

### std

```cpp
#include<bits/stdc++.h>
using i64 = long long;

std::array<i64, 2> p[4];
i64 A, B, C, D;

int chk(i64 x, i64 y) {
    i64 res = B * (x - C) + D - A * y;
    if (res == 0) {
        return 0;
    }
    else if (res > 0) {
        return 1;
    }
    else {
        return -1;
    }
}

void solve() {
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 2; ++j) {
            std::cin >> p[i][j];
        }
    }

    bool ok = true;

    if (std::max(p[2][0], p[3][0]) < p[0][0]) {
        ok = true;
    }
    else if (std::max(p[2][1], p[3][1]) < p[0][1]) {
        ok = true;
    }
    else if (std::min(p[2][0], p[3][0]) > p[1][0]) {
        ok = true;
    }
    else if (std::min(p[2][1], p[3][1]) > p[1][1]) {
        ok = true;
    }
    else {
        A = p[3][0] - p[2][0];
        B = p[3][1] - p[2][1];
        C = p[2][0];
        D = p[2][1] * A;
        std::array<int, 4> pos{};
        for (int i = 0; i < 2; ++i) {
            for (int j = 0; j < 2; ++j) {
                pos[i * 2 + j] = chk(p[i][0], p[j][1]);
            }
        }
    
        for (int i = 1; i < 4; ++i) {
            if (pos[i] != pos[i - 1]) {
                ok = false;
                break;
            }
        }
    }

    std::cout << (ok ? "NO" : "YES") << '\n';
}

int main () {
    // IOS;
    int T = 1;
    std::cin >> T;

    while (T--) {
        solve();
    }
    return 0;
}
```